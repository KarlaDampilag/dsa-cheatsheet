# Set

Set is a data structure that does not contain duplicate items, and the items are ordered by insertion.

## Example Use Cases

Eliminating duplicates, checking the presence of an item in a collection, comparison of two or more lists.

## Set Methods

1. has - checks for the presence of an element.
2. add - inserts a new element if the specified value isn't already in the set. Returns the set object with the added value.
3. delete - removes the specified element. Returns a boolean that asserts whether it was successfully removed or not.
4. values - an iteration method returns all elements in the set.
5. clear - removes all elements from the set.
6. size - returns the number of values in the set.
7. forEach - an iteration method that executes the provided function once for each value in the set.

JavaScript ES6 (ES2015) has a built-in Set object, which contains all of the methods above (set.size in ES6 is a property and not a method).

However, it does not have all of the common methods that are expected from a set data structure, such as the following:

1. union - returns the combined values of two sets.
2. intersection - returns a new set that contains the common elements in two sets.
3. difference - returns a new set that contains elements from the first set which are not in the second set.
4. symmetric difference - returns a new set that contains elements from the first set which are not present in the second set, and elements of the second set which are not present in the first set.
5. is super set - checks if all elements of subset are present in the set.

## Set Data Structure Implementation in TypeScript

```typescript
interface ISet<T> {
    size: number;
    has(item: T): boolean;
    add(item: T): this;
    delete(item: T): boolean;
    clear(): undefined;
    values(): IterableIterator<T>;
    forEach(callbackfn: (value: T, value2: T, set: ISet<T>) => void, thisArg?: any): void;
}

class SetExt<T> implements ISet<T> {
    private items: T[] = [];
    size: number = 0;

    constructor(params: T[]) {
        this.items = [...params];
        this.size = params.length;
    }

    has(item: T): boolean {
        return this.items.indexOf(item) !== -1;
    }
    
    add(item: T): this {
        if (!this.has(item)) {
            this.items.push(item);
            this.size++;
        }
        return this;
    }

    delete(item: T): boolean {
        if (this.has(item)) {
            this.items.splice(this.items.indexOf(item), 1);
            this.size--;
            return true;
        } else {
            return false;
        }
    }

    clear(): undefined {
        this.items = [];
        this.size = 0;
        return undefined;
    }

    values(): IterableIterator<T> {
        return this.items.values();
    }

    forEach(callbackfn: (value: T, value2: T, set: ISet<T>) => void, thisArg?: any): void {
        for (const element of this.values()) {
            callbackfn.call(thisArg, element, element, this);
        }
    }
}
```

The implementation above uses array methods such as `indexOf()` for lookup, which has a linear time complexity O(n). Thus, the above implementation can be improved for performance by using hash tables instead of regular arrays to store the collection. 

## TODO A More Optimized Implementation of Set Using Hash Table

In this implementation, we'll use hash table instead of a simple array, so that the basic operations' run-time complexity is constant O(1) instead of linear O(n). 

TODO optimized implementation using hash table

TODO union, intersection, difference, symmetricDifference, isSuperSet methods

TODO finish hash table data structure page, and link from here.